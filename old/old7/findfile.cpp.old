#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <string>
#include <filesystem> // Використовуємо стандартну бібліотеку <filesystem>

namespace fs = std::filesystem;

std::mutex mtx;

void findFile(const std::string& path, const std::string& target) {
    for (const auto& entry : fs::directory_iterator(path)) {
        const auto& filepath = entry.path().string();
        if (fs::is_directory(entry.status())) {
            {
                std::lock_guard<std::mutex> lock(mtx);
                std::cout << "Thread " << std::this_thread::get_id() << " is entering directory: " << filepath << std::endl;
            }
            findFile(filepath, target); // Рекурсивний виклик для кожної директорії
        } else if (fs::is_regular_file(entry.status()) && entry.path().filename() == target) {
            std::lock_guard<std::mutex> lock(mtx);
            std::cout << "Thread " << std::this_thread::get_id() << " found target file: " << filepath << std::endl;
        }
    }
}

int main() {
    std::string startDir, targetFile;
    
    // Запит введення даних від користувача
    std::cout << "Enter start directory: ";
    std::getline(std::cin, startDir);
    if (startDir.empty()) startDir = "."; // Використовувати поточний каталог, якщо ввід порожній

    std::cout << "Enter target file name: ";
    std::getline(std::cin, targetFile);

    // Використовувати поточний каталог, якщо ввід порожній
    if (targetFile.empty()) {
        std::cerr << "No target file specified." << std::endl;
        return 1;
    }

    // Створення вектора для зберігання потоків
    std::vector<std::thread> threads;

    // Створення 8 потоків
    for (int i = 0; i < 8; ++i) {
        threads.emplace_back(findFile, startDir, targetFile);
    }

    // Чекаємо завершення всіх потоків
    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
